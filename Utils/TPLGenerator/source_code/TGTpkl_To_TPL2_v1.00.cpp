#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <map>
#include <algorithm>
#include <getopt.h>
#include <dirent.h>
#include <unistd.h>
#include <stdio.h>
using namespace std;


//------- AA coding -------//
const int AA2SUB[26]={0,20,1,2,3,4,5,6,7,20,8,9,10,11,20,12,13,14,15,16,20,17,18,20,19,20};
string AA3Coding[26]={"ALA","XXX","CYS","ASP","GLU","PHE","GLY","HIS","ILE","XXX","LYS","LEU","MET","ASN","XXX","PRO","GLN","ARG","SER","THR","XXX","VAL","TRP","XXX","TYR","XXX"};


//-------- utility ------//
void getBaseName(string &in,string &out,char slash,char dot)
{
	int i,j;
	int len=(int)in.length();
	for(i=len-1;i>=0;i--)
	{
		if(in[i]==slash)break;
	}
	i++;
	for(j=len-1;j>=0;j--)
	{
		if(in[j]==dot)break;
	}
	if(j==-1)j=len;
	out=in.substr(i,j-i);
}
void getRootName(string &in,string &out,char slash)
{
	int i;
	int len=(int)in.length();
	for(i=len-1;i>=0;i--)
	{
		if(in[i]==slash)break;
	}
	if(i<=0)out=".";
	else out=in.substr(0,i);
}

//----- just utility ----//
void toUpperCase(string &buffer)
{
	for(int i=0;i<(int)buffer.length();i++) 
	if(buffer[i]>=97 && buffer[i]<=122) buffer[i]-=32;
}
void toLowerCase(string &buffer)
{
	for(int i=0;i<(int)buffer.length();i++) 
	if(buffer[i]>=65 && buffer[i]<=90) buffer[i]+=32;
}

//--------- Parse_Str_Str (automatic) --------//
int Parse_Str_Str(string &in,vector <string> &out)
{
	istringstream www(in);
	out.clear();
	int count=0;
	for(;;)
	{
		string buf;
		if(! (www>>buf) )break;
		out.push_back(buf);
		count++;
	}
	return count;
}


//============ read in TGT file ==============//
int Read_TGT_SEQRES(string &in_file,string &seqres)
{
	ifstream fin;
	string buf,temp;
	//read
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"no such file! %s \n",in_file.c_str());
		exit(-1);
	}
	//process
	int i;
	seqres="";
	for(i=0;i<3;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			fprintf(stderr,"file format bad! %s \n",in_file.c_str());
			exit(-1);
		}
	}
	//[map1]
	if(!getline(fin,buf,'\n'))
	{
		fprintf(stderr,"file format bad! %s \n",in_file.c_str());
		exit(-1);
	}
	istringstream www1(buf);
	for(i=0;i<3;i++)
	{
		if(! (www1>>temp))
		{
			fprintf(stderr,"file bad! %s \n",in_file.c_str());
			exit(-1);
		}
	}
	seqres=temp;
	return (int)seqres.length();
}

//===================== NEFF process ====================//
//[0]record the NEFF for each column
void Tpl_File_All_Neff(string &infile,vector <int> &neff_set,int length)
{
	ifstream fin;
	string buf,temp;
	fin.open(infile.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		printf("file %s not found !!\n",infile.c_str());
		exit(-1);
	}
	//skip
	int i,j;
	int len;
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original HHM file")break;
	}
	for(i=0;i<5;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
	}
	//process
	int neff;
	neff_set.clear();
	for(i=0;i<length;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		istringstream www(buf);
		for(j=0;j<8;j++)
		{
			if(! (www>>temp))
			{
				printf("file format bad! %s \n",infile.c_str());
				exit(-1);
			}
		}
		neff=atoi(temp.c_str());
		neff_set.push_back(neff);
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
	}
	fin.close();
	fin.clear();
}
double Tpl_File_Calc_Neff_II(vector <int> &neff_set,vector <int> &mapping,int length)
{
	int i;
	int tot_neff=0;
	int totcount=0;
	for(i=0;i<length;i++)
	{
		if(mapping[i]==1)
		{
			tot_neff+=neff_set[i];
			totcount++;
		}
	}
	if(totcount==0)return tot_neff;
	else return 1.0*tot_neff/totcount;
}

//===================== output TGT file =================//
/*
//////////// Original SS2 file (generated by PSIPRED)
//////////// 2011-10-29  0:0:30
   1 E C   0.999  0.000  0.001
   2 N C   0.813  0.002  0.243
   3 I E   0.040  0.000  0.959
   4 E E   0.010  0.000  0.992
.....
*/

/*
SS3:   H     E     L  | SS8:   H     G     I     E     B     T     S     L  | ACC:  Bury   Medium  Exposed
   0.000 0.000 1.000       0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000      0.000520 0.021237 0.978243      E 1
   0.000 0.254 0.745       0.000 0.000 0.000 0.379 0.004 0.000 0.000 0.617      0.012561 0.218901 0.768538      N 2
   0.004 0.926 0.072       0.000 0.000 0.000 0.946 0.002 0.000 0.008 0.045      0.481319 0.435151 0.083530      I 3
   0.001 0.980 0.018       0.000 0.000 0.000 0.992 0.000 0.000 0.000 0.008      0.068506 0.447094 0.484400      E 4
.....
*/
void Tpl_File_Cut_Output_Single_II(ifstream &fin,vector <int> &mapping,int length,FILE *fp,int lines=1)
{
	int i,j;
	int len;
	string buf,temp;
	//process
	for(i=0;i<length;i++)
	{
		for(j=0;j<lines;j++)
		{
			if(!getline(fin,buf,'\n'))
			{
				printf("file format bad!\n");
				exit(-1);
			}
			len=(int)buf.length();
			if(len>=12)
			{
				temp=buf.substr(0,12);
				if(temp=="////////////")
				{
					printf("file format bad!\n");
					exit(-1);
				}
			}
			if(mapping[i]==1)fprintf(fp,"%s\n",buf.c_str());
		}
	}
}
//----- get mapping ------//
/*
from ->
   0.000 0.000 1.000       0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000      0.000520 0.021237 0.978243      E 1
to   ->
   1 E C   0.999  0.000  0.001
*/
void Get_SS2_Mapping_String(string &in,string &out)
{
	vector <string> rec;
	istringstream www(in);
	for(int i=0;i<16;i++)
	{
		string temp;
		if(! (www>>temp) )
		{
			printf("file format bad!\n");
			exit(-1);
		}
		rec.push_back(temp);
	}
	//output
	char command[30000];
	int pos=atoi(rec[15].c_str());
	char ami=rec[14][0];
	double h_prob=atof(rec[0].c_str());
	double e_prob=atof(rec[1].c_str());
	double c_prob=atof(rec[2].c_str());
	char sse='C';
	if(h_prob>e_prob && h_prob>c_prob)sse='H';
	if(e_prob>h_prob && e_prob>c_prob)sse='E';
	sprintf(command,"%4d %c %c %7.3f%7.3f%7.3f\n",pos,ami,sse,c_prob,h_prob,e_prob);
	out=command;
}
//----- real process -----//
void TGT_File_Cut_Output_II(ifstream &fin,vector <int> &mapping,int length,FILE *fp)
{
	string buf,temp;
	string header,head;
	string time_line;
	int i,j;
	int len;

	//[2-2] output psi_blast_1
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original PSM file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	time_line=header;
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp);
	fprintf(fp,"\n\n\n");

	//[2-3] output psi_blast_2
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original PSP file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp);
	fprintf(fp,"\n\n\n");

	//[2-6] output HHpred
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original HHM file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	for(i=0;i<4;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		fprintf(fp,"%s\n",buf.c_str());
	}
	//output HMM body
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp,3);
	fprintf(fp,"\n\n\n");


	//[2-7] output structure info
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original SS3+SS8+")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	if(!getline(fin,temp,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	string ss2_header="//////////// Original SS2 file (generated by PSIPRED)";
	fprintf(fp,"%s\n",ss2_header.c_str());
	fprintf(fp,"%s\n",time_line.c_str());
	//---- output TGT derived SS2 info -----//
	int lines=1;
	for(i=0;i<length;i++)
	{
		for(j=0;j<lines;j++)
		{
			if(!getline(fin,buf,'\n'))
			{
				printf("file format bad!\n");
				exit(-1);
			}
			len=(int)buf.length();
			if(len>=12)
			{
				temp=buf.substr(0,12);
				if(temp=="////////////")
				{
					printf("file format bad!\n");
					exit(-1);
				}
			}
			if(mapping[i]==1)
			{
				string sse_str;
				Get_SS2_Mapping_String(buf,sse_str);
				fprintf(fp,"%s",sse_str.c_str());
			}
		}
	}
}


//============ read in FEAT file =============//
//-> file format
/*
  Num Res  Missing   SSE    CLE   ACC   pACC  CNa CNb   Xca       Yca       Zca       Xcb       Ycb       Zcb
   1   E      0       L      R     2     87   2   1     19.375     4.600    31.639    17.889     4.542    31.872
   2   N      0       E      R     2     48   4   3     20.501     7.608    33.670    21.326     8.630    32.887
   3   I      0       E      E     1     18   3   5     18.924     9.098    36.780    18.496     8.208    37.931
   4   E      0       E      E     2     53   3   2     19.887    12.671    37.725    19.630    13.781    36.734
   5   V      0       E      E     0      0   6   9     20.160    13.626    41.423    20.814    12.502    42.276
*/
int FEAT_File_Input(string &in_file,vector <vector <string> >&out,string &ami_)
{
	ifstream fin;
	string buf,temp;
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"%s not found!\n",in_file.c_str());
		exit(-1);
	}
	//skip first
	if(!getline(fin,buf,'\n'))
	{
		fprintf(stderr,"%s format error!\n",in_file.c_str());
		exit(-1);
	}
	//load
	out.clear();
	ami_="";
	int count=0;
	int first=1;
	int colsize=0;
	for(;;)
	{
		if(!getline(fin,buf,'\n'))break;
		vector <string> tmp_str;
		int len=Parse_Str_Str(buf,tmp_str);
		if(first==1)
		{
			colsize=len;
			first=0;
		}
		else
		{
			if(colsize!=len)
			{
				fprintf(stderr,"colsize %d not equal to len %d\n",
					colsize,len);
				exit(-1);
			}
		}
		istringstream www(buf);
		www>>temp>>temp;
		out.push_back(tmp_str);
		ami_+=temp;
		count++;
	}
	return count;
}


//============ read in map file ===========//
void Read_MAP_string(string &map_file,string &seqres_str,string &dssp_str) //->from .fasta file
{
	ifstream fin;
	string buf,temp;
	//read
	fin.open(map_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"no such file! %s \n",map_file.c_str());
		exit(-1);
	}
	//process
	if(!getline(fin,seqres_str,'\n'))
	{
		fprintf(stderr,"file %s format bad \n",map_file.c_str());
		exit(-1);
	}
	if(!getline(fin,dssp_str,'\n'))
	{
		fprintf(stderr,"file %s format bad \n",map_file.c_str());
		exit(-1);
	}
}


//---- readme ----//
void Usage(char *arg) 
{
	printf("Version: 1.00 \n");
	printf("Usage: %s -i tplpkl_file -I tgt_file [ -o tpl_file] [-t tmp] [-H home] \n",arg);
}
//---- parameter editor ----//
static option long_options[] =
{
	{"input",   required_argument, NULL, 'i'},
	{"Input",   required_argument, NULL, 'I'},
	{"output",  no_argument,       NULL, 'o'},
	{"tmpout",  no_argument,       NULL, 't'},
	{"home",    no_argument,       NULL, 'H'},
	{0, 0, 0, 0}
};

//------------ main -----------//
int main(int argc, char** argv)
{

	if(argc<2)
	{
		Usage(argv[0]);
		exit(-1);
	}
	string tplpkl="";
	string tgtfile="";
	string outnam="";
	string tmpout="";
	string home="";

	//extern int optind;
	char c = 0;
	int option_index=0;
	extern char* optarg;
	while ((c = getopt_long(argc, argv, "i:I:o:t:H:",long_options,&option_index)) != EOF) 
	{
		switch (c) 
		{
			case 'i':
				tplpkl = optarg;
				break;
			case 'I':
				tgtfile = optarg;
				break;
			case 'o':
				outnam = optarg;
				break;
			case 't':
				tmpout = optarg;
				break;
			case 'H':
				home = optarg;
				break;
			default:
				Usage(argv[0]);
				exit(-1);
		}
	}
	//check input file
	int retv;
	if(tplpkl=="")
	{
		Usage(argv[0]);
		exit(-1);
	}
	if(tgtfile=="")
	{
		Usage(argv[0]);
		exit(-1);
	}
	string innam="";
	getBaseName(tgtfile,innam,'/','.');
	string fileout="";
	getBaseName(outnam,fileout,'/','.');
	string templateName;
	if(fileout=="")templateName = innam;
	else templateName = fileout;
	if(outnam=="")outnam=templateName+".tpl";

	//home and tmp dir
	char *wd(getcwd(NULL,0));
	string cwd(wd);
	free(wd);
	if(tmpout=="")tmpout=cwd+"/tmp_"+templateName+"/";
	string mkdir_cmd = "mkdir -p "+tmpout;
	system(mkdir_cmd.c_str());
	if(home=="")home=cwd+"/";


//---------------- read SEQRES from PDB -------------// part_I
	//----- first output sequence -------//__110830__//
	string sequence = "";
	int fullLen=Read_TGT_SEQRES(tgtfile,sequence);
	int ori_full_len=fullLen;
	if(fullLen==0)
	{
		fprintf(stderr,"tgtfile %s format bad \n",tgtfile.c_str());
		exit(-1);
	}

	//----- dump TPLPKL ------//
	string Dump_CMD= "python " + home + "/util/DumpTPLPKL.py " + tplpkl + " " + tmpout + "/" + templateName + ".feature" + " " + tmpout + "/" + templateName + ".mapstr" ;
	retv=system(Dump_CMD.c_str());
	//load feature file
	string feat_file= tmpout + "/" + templateName + ".feature";
	vector <vector <string> > pdb_feature;
	string pdb_ami;
	int pdb_len=FEAT_File_Input(feat_file,pdb_feature,pdb_ami);
	//load map string
	string map_file = tmpout + "/" + templateName + ".mapstr";
	string seqres_str,dssp_str;
	Read_MAP_string(map_file,seqres_str,dssp_str);
	
	//------- checking mapping i ------//__110710__//
	int index = 0;
	vector<int> mapping;
	for(int i=0;i<(int)dssp_str.length();i++)
	{
		if(dssp_str[i]=='-')
		{
			mapping.push_back(-1);
		}
		else
		{
			mapping.push_back(index);
			index++;
		}
	}
	//---- checking mapping ii ----//__110830__//
	{
		int wi;
		int wlen1=(int)sequence.length();
		int wlen2=(int)dssp_str.length();
		if(index!=pdb_len)
		{
			fprintf(stderr," mapping length not equal to pdb length [%d!=%d] !!!\n",index,pdb_len);
			exit(-1);
		}
		if(wlen1!=wlen2)
		{
			fprintf(stderr,"mapping length not equal [%d!=%d] !!!\n",wlen1,wlen2);
			exit(-1);
		}
		if(sequence!=seqres_str)
		{
			fprintf(stderr,"mapping sequence not equal [%s!=%s] !!!\n",sequence.c_str(),seqres_str.c_str());
			exit(-1);
		}
		int wlen=wlen1;
		for(wi=0;wi<wlen;wi++)
		{
			if(dssp_str[wi]=='-')continue;
			if(dssp_str[wi]!=sequence[wi])sequence[wi]=dssp_str[wi];
		}
	}


	//======================= remove non-standard residues ===================//
	vector <int> mapping_ii;
	mapping_ii.resize(fullLen);
	for(int i=0;i<fullLen;i++)mapping_ii[i]=1;


// get current time
	time_t t = time(NULL);
	struct tm tm = *localtime(&t);

// read NEFF
	float NEFF;
	{
		//read_in neff
		vector <int> neff_set;
		Tpl_File_All_Neff(tgtfile,neff_set,ori_full_len);
		double tot_neff=1.0*Tpl_File_Calc_Neff_II(neff_set,mapping_ii,ori_full_len)/1000;
		int tot_neff_int=(int)tot_neff;
		double tot_neff_small=tot_neff-tot_neff_int+0.05;
		int tot_neff_sma=(int)(10.0*tot_neff_small);
		NEFF=tot_neff_int+0.1*tot_neff_sma;
	}

// TPL file
	string out_filename=outnam;
	FILE *fp=fopen(out_filename.c_str(),"wb");
// output all features
	fprintf(fp,"Version 1.1\n");
	fprintf(fp,"Template Name  = %s\n",templateName.c_str());
	fprintf(fp,"Chain ID = _\n");
	fprintf(fp,"Length  = %d\n",fullLen);
	fprintf(fp,"SEQRES sequence = %s\n",sequence.c_str());
	fprintf(fp,"DSSP   sequence = %s\n",dssp_str.c_str());
	fprintf(fp,"NEFF = %3.1f\n",NEFF);
	fprintf(fp,"Date = %d-%d-%d %d:%d%d\n",
		tm.tm_year + 1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_hour,tm.tm_sec);

//--------------- output structural features --------------//
{
	const int BufLen = 100000;
	fprintf(fp,"\n\n");
	fprintf(fp,"//////////// Features \n");
	fprintf(fp,"  Num Res  Missing   SSE    CLE   ACC   pACC  CNa CNb   Xca       Yca       Zca       Xcb       Ycb       Zcb\n");
	int cur_pos=0;
	for(int i=0;i<fullLen;i++)
	{
		char tmp[BufLen];
		sprintf(tmp,"%4d", i+1);
		if(mapping[i]>=0)
		{
			fprintf(fp,"%s%4s%7s%8s%7s%6s%7s%4s%4s   %8s  %8s  %8s  %8s  %8s  %8s\n",tmp,
				pdb_feature[cur_pos][1].c_str(),pdb_feature[cur_pos][2].c_str(),pdb_feature[cur_pos][3].c_str(),pdb_feature[cur_pos][4].c_str(),pdb_feature[cur_pos][5].c_str(),
				pdb_feature[cur_pos][6].c_str(),pdb_feature[cur_pos][7].c_str(),pdb_feature[cur_pos][8].c_str(),pdb_feature[cur_pos][9].c_str(),pdb_feature[cur_pos][10].c_str(),
				pdb_feature[cur_pos][11].c_str(),pdb_feature[cur_pos][12].c_str(),pdb_feature[cur_pos][13].c_str(),pdb_feature[cur_pos][14].c_str(),pdb_feature[cur_pos][15].c_str());
			cur_pos++;
		}
		else
		{
			char sse='L';
			char cle='R';
			char acc='2';
			fprintf(fp,"%s   %c      %1d       %c      %c     %c   ",tmp,sequence[i],(mapping[i]<0),sse,cle,acc);
			int pacc=45;
			int can=0;
			int cbn=0;
			sprintf(tmp,"%4d  %2d  %2d", pacc, can, cbn);
			fprintf(fp,"%s   \n",tmp);
		}
	}
	fprintf(fp,"\n\n\n");
}


//---------------- output sequence features ---------------//
	ifstream fin;
	fin.open(tgtfile.c_str(), ios::in);
	TGT_File_Cut_Output_II(fin,mapping_ii,ori_full_len,fp);
	fin.close();
	fclose(fp);

// delete junk
	string rm_command;
	rm_command = "";
	rm_command = rm_command + "rm -f error.log";
	retv=system(rm_command.c_str());

// move important file
	{
		//string mvtmp_command;
		//mvtmp_command = "mv " + tmpout + "/" +templateName+".pdb " + templateName+".pdb_post";
		//retv=system(mvtmp_command.c_str());
	}

// keep temporary files or not
//	if(keeptmp==0)
	{
		string rmtmp_command;
		rmtmp_command = "rm -f " + tmpout + "/"  + templateName + "*";
		retv=system(rmtmp_command.c_str());
		rmtmp_command = "rmdir " + tmpout;
		retv=system(rmtmp_command.c_str());
	}

}


