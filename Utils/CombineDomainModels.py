import os
import sys
#import subprocess

import numpy as np
import getopt
import shutil

from Common import PDBUtils
from Common.SequenceUtils import LoadFASTAFile

## this script combine domain models into whole-chain models using structure alignment
## please make sure DeepScore is in bin path
def Usage():
	print 'python CombineDomainModels.py [-d savefolder ] WholeChainModelFile D1ModelFile D2ModelFile ...'
	print '	This script combines domain models into a whole-chain model using model structure alignment'
	print '		Please make sure that an exectuable program DeepScore is available'
	print '	WholeChainModelFile: an initial whole-chain model, which is used as the overall scaffold'
	print '		the residue number in this model shall start from 1 and be continuous'
	print '	DmodelFiles: the model files for all domains'
	print '		The domain models shall not have overlapping residues'
	print '	The resultant whole-chain model is purely formed by the domain models. There may be some gaps in the result if the domain models do not contain all residues'

## here we assume that the local quality (distance deviation) occpuies columns 61-66 in the ATOM record of a PDB file
def ExtractLocalQuality(pdbfile):
	with open(pdbfile, 'r') as fh:
		#CAquality = [ line[60:66] for line in list(fh) if line.startswith('ATOM ') and line[12:16] == ' CA ' ]
		CAquality = [ line.strip()[60:66] for line in list(fh) if line.startswith('ATOM ') and line[12:16] == ' CA ' ]

	#print CAquality

	for qStr in CAquality:
		q = np.float32(qStr[:6])
		if q < 0 or q>100:
			print 'WARNING: the local quality is not in [0, 100]. Please double check to make sure this pdb file indeed contains local error estimate: ', pdbfile
			break

	return CAquality

## modelFile is generated by DeepScore, which is the superimposition of the two structures
## here we read from head until seeing 'TER'
def ExtractNewDomainModel(modelFile):
	with open(modelFile, 'r') as fh:
		content =  [line.strip() for line in list(fh)]

	atomRecords = []
	for c in content:
		if c.startswith('TER'):
			break;

		if not c.startswith('ATOM'):
			continue

		atomRecords.append(c)

	return atomRecords

if __name__ == "__main__":

	if len(sys.argv) < 3:
		Usage()
		exit(1)
	
	try:
		opts, args = getopt.getopt(sys.argv[1:], "d:", ["savefolder=="])
	except getopt.GetoptError as err:
		Usage()
		exit(1)

	savefolder = os.getcwd()
	for opt, arg in opts:
		if opt in ("-d", "--savefolder"):
			savefolder = arg
			if not os.path.isdir(savefolder):
				os.mkdir(savefolder)
		else:
			Usage()
			exit(1)

	if len(args) < 2:
		Usage()
		exit(1)

	initModelFile = args[0]
	if not os.path.isfile(initModelFile):
		print "ERROR: invalid initial whole-chain model file: ", initModelFile
		exit(1)

	pdbseqs, _, chains = PDBUtils.ExtractSeqFromPDBFile(initModelFile)
	assert len(pdbseqs) == 1
	mainSeq = pdbseqs[0]

	domainModels = args[1:]

	domainSeqs = []
	localQualitys = []
	for dmodel in domainModels:
		pdbseqs, _, chains = PDBUtils.ExtractSeqFromPDBFile(dmodel)
		assert len(pdbseqs) == 1
		domainSeqs.append( pdbseqs[0] )
		#print 'chain id: ', chains[0].get_id()
		locQuality = ExtractLocalQuality(dmodel)
		assert len(locQuality) == len(pdbseqs[0])
		localQualitys.append( locQuality )

	## align domainSeqs to mainSeq
	startPositions = []
	quality = [ ' 99.00' ] * len(mainSeq)
	for dSeq, locQuality in zip(domainSeqs, localQualitys):
		index = mainSeq.find(dSeq)
		if index < 0:
			print 'ERROR: cannot map the domain sequence to the whole-chain sequence'
			print 'domain seq: ', dSeq
			print 'whole  seq: ', mainSeq
			exit(1)
		quality[index: index + len(dSeq) ] = locQuality
		startPositions.append(index)

	## align domain models to the whole-chain model
	pid = os.getpid()
	newDomainModelRecords = []
	for dmodel in domainModels:
		newDomainModel = 'tmpRX' + str(pid) + os.path.basename(dmodel)
		cmds = ['DeepScore', dmodel, initModelFile, '-o', newDomainModel]
		cmdStr = ' '.join(cmds)
		os.system(cmdStr)

		## extract corresponding domain model coordinates
		atomRecords = ExtractNewDomainModel(newDomainModel + '.pdb')
		newDomainModelRecords.append(atomRecords)

	## change residue number and atom number
	newAtomRecords = []
	for startPos, dAtomRecords in zip(startPositions, newDomainModelRecords):
		resNumber = startPos
		## here atomNumber is only a temporary number and will be revised later
		atomNumber = resNumber * 50 
		prevResNumber = -10000
		for atomRecord in dAtomRecords:
			##atomRecord[22:26] is the residue number
			currResNumber = np.int32(atomRecord[22:26])
			if currResNumber != prevResNumber:
				resNumber += 1
				prevResNumber = currResNumber

			newAtomRecords.append( (atomNumber, resNumber, atomRecord) )
			atomNumber += 1

	## sort newAtomRecords by resNumber and atomNumber
	finalAtomRecords = sorted(newAtomRecords, key=lambda x:(x[1], x[0]) )

	## write the final atom records including local quality
	outStrs = []
	for atomNumber, record in zip(range(1, 1+len(finalAtomRecords)), finalAtomRecords):
		atomRecord = record[2]
		resNumber = record[1]

		##'ATOM '
		firstPart = atomRecord[0:6]

		## atom number
		secondPart = '{:5d}'.format(atomNumber)

		## atom name, atlLoc, residue name, chain ID
		thirdPart = atomRecord[11:22]

		## the residue number
		forthPart = '{:4d}'.format(record[1])

		## insertion code, coordinates, occupany
		fifthPart = atomRecord[26:60]

		## error estimate
		sixthPart = quality[resNumber - 1]

		newRecord = firstPart + secondPart + thirdPart + forthPart + fifthPart + sixthPart
		outStrs.append(newRecord)
	
	## write to a file
	names = [ os.path.basename(dModelFile).split('.')[0] for dModelFile in domainModels ]
	mainName = '-'.join(names)
	savefile = mainName + '.pdb'
	savefile = os.path.join(savefolder, savefile)

	with open(savefile, 'w') as fh:
		fh.writelines('\n'.join(outStrs) )			
