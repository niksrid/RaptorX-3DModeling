import numpy as np
import random
import sys
import os

##this program reads a rank file generated by CNFsearch or MRFsearch and keeps a few top templates

MaxNumTemplates = 25

## select templates by certain strategy
def SelectTemplates(templateScore_list, strategy=None):

	##exclude very good and very bad templates
	pool4selection = [ temp for temp in templateScore_list if temp[2]<=0.4 and temp[3]<=0.003 ]

	##if two few choices are left
	if len(pool4selection) < 2:
		pool4selection = templateScore_list[:3]

	## now choose some template from remaining randomly
	random.shuffle(pool4selection)

	##here we just choose one, but you may choose more by a slight revision of the below sentence
	selectedTemplates = pool4selection[: 1]

	## we have to sort here by template number
	selectedTemplates.sort(key=lambda x: x[0])

	#print selectedTemplates

	return selectedTemplates


## read in the .rank file

def LoadRankFile(file_name, strategy=None):
	fin = open(file_name, 'r')
	content = fin.readlines()
	fin.close()

	query_name = ''
	query_fullseq = ''
	templateScore_list = []
	query_length = 1

	index = 0
	while index < len(content):
		line = content[index]
		array = line.strip().split()
	
		if len(array) >= 4 and array[0] == "Query" and array[1] == "Name":
                	query_name = array[3]

		if len(array) >= 4 and array[0] == "Query" and array[1] == "Sequence":
			query_fullseq = array[3]

		if len(array) >= 4 and array[0] == "Query" and array[1] == "Length":
			query_length = np.int32(array[3])
		
		if len(array) > 5 and array[0] == "No" and array[1] == "Template" and array[2] == "Pvalue":
			num_tmp = 0
			while num_tmp < MaxNumTemplates:
				index += 1
				num_tmp += 1
				line = content[index]
				array = line.strip().split()
				if len(array) != 13:
					break

				## for small proteins, we reduce its seqID a little bit since for this kind of proteins, a higher seqID is needed to warrant structure similarity
				seqID = np.float32(array[-1])/max(np.sqrt(query_length*120), query_length)
				real_seqID = np.float32(array[-1])/query_length

				Pvalue = np.float32(array[2])

				templateScore_list.append( ( np.int32(array[0]), array[1], seqID, Pvalue, query_name, real_seqID))
			break
		index += 1

	##select some templates
	selectedTemplates = SelectTemplates(templateScore_list, strategy=None)

	result = []

	while index < len(content) - 1:
		index += 1
		line = content[index]
		array = line.strip().split()
		if len(array) >= 2 and array[0] == "No" and np.int32(array[1]) in [temp[0] for temp in selectedTemplates ]:
		
			index += 1
			line = content[index]
			template_name = line.strip()[1:]
		
			index += 4
			line = content[index]
			array = line.strip().split()
		
			assert len(array) == 6

			tpl_start = int(array[2])
			tpl_seq = array[3]
			tpl_end = int(array[4])
		
			index += 2
			line = content[index]
			array = line.strip().split()

			assert len(array) == 6

			query_start = int(array[2])
			query_seq = array[3]
			query_end = int(array[4])
		
			index += 1
			line = content[index]
			array = line.strip().split()
			
			while not (len(array) == 2 and array[0] == 'No'):
				if len(array) > 2 and array[0] == 'T' and array[1] == 'sse_real':
					index += 2
					line = content[index]
      		          		array = line.strip().split()

                			assert len(array) == 6
                
        	        		tpl_seq += array[3]
					tpl_end = int(array[4])

		                	index += 2
 		               		line = content[index]
	                		array = line.strip().split()

	                		assert len(array) == 6

	                		query_seq += array[3]
					query_end = int(array[4])
		
				index += 1
	                	line = content[index]
	                	array = line.strip().split()
			index -= 1
			result.append((template_name, query_name, tpl_start, query_start, tpl_seq, query_seq, tpl_end, query_end))

		if len(result) == len(selectedTemplates):
			break


	assert ( len(result) == len(selectedTemplates) )

	## add the head and tail gaps to the alignment so that the full query sequence appears in the alignment
	result2 = []
	for res, temp in zip(result, selectedTemplates):
		#print res[0], temp[1]
		assert res[0] == temp[1]
		t_name, q_name, t_start, q_start, t_seq, q_seq, t_end, q_end = res
		new_q_seq = query_fullseq[ : q_start-1] + q_seq + query_fullseq[ q_end : ]
		new_t_seq = ('-'*(q_start - 1)) + t_seq + ('-'*(query_length - q_end) )

		result2.append( (t_name, q_name, temp[5], temp[3], new_t_seq, new_q_seq) )

	return result2

##Usage "python load_rank.py target.rank" where target.rank is the ranking file generated by MRFsearch or CNFsearch
if __name__ == "__main__":

	result = LoadRankFile(sys.argv[1])

	for (template_name, query_name, score1, score2, tpl_seq, query_seq) in result:

		"""
		tmp_query_seq = ''
		tmp_tpl_seq = ''
		for i in range(query_start):
			tmp_query_seq += '-'
			tmp_tpl_seq += '-'
		tmp_query_seq += query_seq
		tmp_tpl_seq += tpl_seq
		"""

		"""	
		fout = open("result/" + query_name + '_' + template_name + '.fasta', 'w')
		fout.write(">" + query_name + "\n")
		fout.write(tmp_query_seq + "\n")
		fout.write(">" + template_name + "\n")
		fout.write(tmp_tpl_seq + "\n")
		fout.close()
		"""

		if not os.path.isdir('result/'):
			os.mkdir('result/')

		savefilename = os.path.join('result/',  template_name + '_' + query_name + '.fasta' )
		fout = open(savefilename, 'w')
		fout.write(">" + template_name + "\n")
		fout.write(tpl_seq + "\n")
		fout.write(">" + query_name + "\n")
		fout.write(query_seq + "\n")
		fout.close()

		print template_name, query_name, score1, score2

