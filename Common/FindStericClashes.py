import os
import sys
import random
import cPickle
import numpy as np

from SequenceUtils import LoadFASTAFile
import PDBUtils
from CIF2PDB import CIF2PDB

if __name__ == "__main__":
	if len(sys.argv) < 2:
		#print 'python CalcDistMatrixFromSeqPDB.py structFile seqFile [cutoff]'
		print 'python CalcDistMatrixFromSeqPDB.py structFile [cutoff]'
		print '	This script calculates only distance matrices from a protein structure file and a sequence file'
		print '	structFile: a protein structure file ending with .cif or .pdb'
		#print '	seqFile: a file for primary sequence in FASTA format. It is used to determine which residues shall be selected from the structure file'
		print '	cutoff: the distance cutoff for CaCa and CbCb clashes, default 3.5'
		exit(1)

	cutoff = 3.5

	structfile = sys.argv[1]
	name = os.path.basename(structfile).split('.')[0]
	sequence = None

	if len(sys.argv) >= 3:
		cutoff = np.float32(sys.argv[2])
		assert cutoff>3

	if structfile.endswith('.cif'):
                ## convert this file to a temporary PDB file; we do this because the old dssp does not work for .cif file
                ## and the new dssp does not work with the .cif file generated by SelectProteinChains.py
                pdbfile = name + str(os.getpid()) + str(random.randint(0, 1000)) + '.pdb'
                pdbfile = os.path.join(ResDir, pdbfile)
                CIF2PDB(structfile, pdbfile)
                pdbfileIsTemporary = True

        elif structfile.endswith('.pdb'):
                pdbfile = structfile
                pdbfileIsTemporary = False
        else:
                print 'ERROR: the input structure file shall end with .cif or .pdb'
                exit(1)

	protein = dict()
	protein['name'] = name

	if sequence is None:
		pdbseqs, _, _ = PDBUtils.ExtractSeqFromPDBFile(pdbfile)
		if len(pdbseqs) != 1:
			print 'ERROR: the pbdfile has more than 1 chains and we do not know which one to choose: ', pdbfile
			exit(1)

		sequence = pdbseqs[0]

	protein['sequence'] = sequence	
	protein['seq4matrix'] = sequence	

	result, pdbseq, numMisMatches, numMatches = PDBUtils.ExtractCoordinatesBySeq(sequence, pdbfile)

	if numMisMatches > 5:
                print 'ERROR: too many mismatches between query sequence and ATOM record in ', pdbfile
                exit(1)

        if numMatches < min(30, 0.5*len(sequence)):
                print 'ERROR: more than half of query sequence not covered by ATOM record in ', pdbfile
                exit(1)

	protein['pdbseq'] = pdbseq
	protein['numMisMatches'] = numMisMatches
	protein['numMatches'] = numMatches

	coordinates, numInvalidAtoms = result
	if numInvalidAtoms.has_key('CA') and numInvalidAtoms['CA']>10:
		print 'ERROR: too many Ca atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	if numInvalidAtoms.has_key('CB') and numInvalidAtoms['CB']>10:
		print 'ERROR: too many Cb atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	
        protein['missing'] = [ c is None or (c['CA'] is None and c['CB'] is None) for c in coordinates ]

	distMatrix = PDBUtils.CalcDistMatrix(coordinates)

	CaCa = distMatrix['CaCa']
	np.fill_diagonal(CaCa, 100)
	CaCaClashes = np.where(CaCa < cutoff )
	print "Ca-Ca clashes (residue pairs and their distance):"
	for i, j, d in zip(CaCaClashes[0], CaCaClashes[1], CaCa[CaCaClashes]):
		print i, j, d
	#print CaCaClashes, CaCa[CaCaClashes]

	CbCb = distMatrix['CbCb']
	np.fill_diagonal(CbCb, 100)
	CbCbClashes = np.where(CbCb < cutoff)
	print "\nCb-Cb clashes (residue pairs and their distance):"
	for i, j, d in zip(CbCbClashes[0], CbCbClashes[1], CbCb[CbCbClashes]):
		print i, j, d

	NO = distMatrix['NO']
	NOClashes = np.where(NO < 2.)
	print "\nN-O clashes (residue pairs and their distance):"
	for i, j, d in zip(NOClashes[0], NOClashes[1], NO[NOClashes]):
		print i, j, d

	if pdbfileIsTemporary:
                os.remove(pdbfile)

