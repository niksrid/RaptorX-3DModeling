import os
import sys
import random
import cPickle

from SequenceUtils import LoadFASTAFile
import PDBUtils
from CIF2PDB import CIF2PDB

if __name__ == "__main__":
	if len(sys.argv) < 3:
		print 'python CalcDistMatrixFromSeqPDB.py structFile seqFile [resDir]'
		print '	This script calculates only distance matrices from a protein structure file and a sequence file'
		print '	structFile: a protein structure file ending with .cif or .pdb'
		print '	seqFile: a file for primary sequence in FASTA format. It is used to determine which residues shall be selected from the structure file'
		print '	resDir: the folder for result saving, default current work directory'
		print '		the resultant file is named after targetName.atomDistMatrix.pkl where targetName is the basename of seqFile'
		exit(1)

	structfile = sys.argv[1]
	name = os.path.basename(structfile).split('.')[0]
	sequence = None
	if len(sys.argv) >=3:
		seqfile = sys.argv[2]
		if os.path.isfile(seqfile):
			sequence = LoadFASTAFile(seqfile)
			name = os.path.basename(seqfile).split('.')[0]

	resDir = os.getcwd()
	if len(sys.argv) >= 4:
		resDir = sys.argv[3]
		if not os.path.isdir(resDir):
			print 'ERROR: the result directory does not exist: ', resDir
			exit(1)

	if structfile.endswith('.cif'):
                ## convert this file to a temporary PDB file; we do this because the old dssp does not work for .cif file
                ## and the new dssp does not work with the .cif file generated by SelectProteinChains.py
                pdbfile = name + str(os.getpid()) + str(random.randint(0, 1000)) + '.pdb'
                pdbfile = os.path.join(ResDir, pdbfile)
                CIF2PDB(structfile, pdbfile)
                pdbfileIsTemporary = True

        elif structfile.endswith('.pdb'):
                pdbfile = structfile
                pdbfileIsTemporary = False
        else:
                print 'ERROR: the input structure file shall end with .cif or .pdb'
                exit(1)

	protein = dict()
	protein['name'] = name

	if sequence is None:
		pdbseqs, _, _ = ExtractSeqFromPDBFile(pdbfile)
		if len(pdbseqs) != 1:
			print 'ERROR: the pbdfile has more than 1 chains and we do not know which one to choose: ', pdbfile
			exit(1)

		sequence = pdbseqs[0]

	protein['sequence'] = sequence	
	protein['seq4matrix'] = sequence	

	result, pdbseq, numMisMatches, numMatches = PDBUtils.ExtractCoordinatesBySeq(sequence, pdbfile)

	if numMisMatches > 5:
                print 'ERROR: too many mismatches between query sequence and ATOM record in ', pdbfile
                exit(1)

        if numMatches < min(30, 0.5*len(sequence)):
                print 'ERROR: more than half of query sequence not covered by ATOM record in ', pdbfile
                exit(1)

	protein['pdbseq'] = pdbseq
	protein['numMisMatches'] = numMisMatches
	protein['numMatches'] = numMatches

	coordinates, numInvalidAtoms = result
	if numInvalidAtoms.has_key('CA') and numInvalidAtoms['CA']>10:
		print 'ERROR: too many Ca atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	if numInvalidAtoms.has_key('CB') and numInvalidAtoms['CB']>10:
		print 'ERROR: too many Cb atoms do not have valid 3D coordinates in ', pdbfile
		exit(1)
	
        protein['missing'] = [ c is None or (c['CA'] is None and c['CB'] is None) for c in coordinates ]

	distMatrix = PDBUtils.CalcDistMatrix(coordinates)
	protein['atomDistMatrix'] = PDBUtils.PostProcessDistMatrix(sequence, distMatrix)

	savefile = os.path.join(resDir, protein['name'] + '.atomDistMatrix.pkl')
	with open(savefile, 'w') as fh:
		cPickle.dump(protein, fh, protocol=cPickle.HIGHEST_PROTOCOL)

	if pdbfileIsTemporary:
                os.remove(pdbfile)

